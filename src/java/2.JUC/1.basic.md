---
date: 2022-12-11
category:
  - JAVA
tag:
  - 并发
  - 概念
---

# JAVA 并发 - 基本概念

[[toc]]

## 1.进程与线程的区别
进程是正在运行的程序实例，一个进程中包含了1-n个线程，每个线程执行不同的任务，线程是程序执行最小的执行单位。
不同的进程使用不同的内存空间，在当前进程下所有的线程共享内存空间。
引申一个问题，单核CPU执行并发线程，实际上是串行的，只不过CPU通过时间片分时复用速度足够快，看起来像是并行的。

## 2.并发三大要素
1、原子性：一个线程在CPU中的操作要么就全执行完成，要么就不执行，不可中断暂停（例如i++，并非原子操作）；**解决方案**：Lock、Synchronized
2、可见性：一个线程对共享变量的修改对其他的线程可见（存在CPU缓存，导致其他线程不一定可见）；**解决方案**：Lock、Synchronized、volatile
3、有序性：CPU中指令执行的顺序有序，不可被重排序（编译器、操作系统都会对指令中排序）；**解决方案**：volatile

## 3.锁的常见概念

### 3.1 乐观锁、悲观锁
乐观锁与悲观锁是一种广义上的概念。
**乐观锁**：CAS操作就是乐观锁的一种实现，最乐观的估计，不怕其他线程修改共享变量，就算修改了自己吃点亏再重试呗。
**悲观锁**：synchronized锁是一种悲观锁，最悲观的估计，需要防着其他所有线程修改共享变量，所以自己独占此变量，不让其他线程修改。

### 3.2 自旋锁
阻塞或者唤醒一个Java线程需要操作系统切换CPU状态来完成，这种操作比较耗费处理器时间，在很多场景中，同步资源的锁定时间其实没有那么长，为了这一小段时间来切换线程可能有些得不偿失。
如果有CPU有多核，能够让两个以上的线程并发执行（单核也没有并发问题），可以让没获取到锁的线程不放弃CPU的执行时间，自旋等待看看能不能很快获取到锁。CAS操作就是自旋锁的一个实现。
所以说实际上就是通过while()的死循环来持续等待直到获取锁，这种方式在锁定时间较短的时候比较适用，如果时间较长则反而会影响性能，可以通过配置`-XX:PreBlockSpin`修改最大自旋次数。

### 3.3 公平锁、非公平锁
**公平锁**是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，只有队列中的第一个线程才能获得锁。
**非公平锁**是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。
两种方式各有优缺点，相对来说公平锁会执行更多的CPU阻塞和唤醒的操作，性能相对较低。

### 3.4 可重入锁、非可重入锁
首先看一段代码：
```java
    final Object Lock = new Object();

    public void doSomething() {
        synchronized (Lock) {
            System.out.println("方法1执行...");
            doOthers();
        }
    }

    public void doOthers() {
        synchronized (Lock) {
            System.out.println("方法2执行...");
        }
    }
```
如果synchronized不是可重入锁，那么这段代码势必会造成死锁，因为doSomething()与doOthers()两个方法内均需要获取Lock，但运行结果如下：
```java
方法1执行...
方法2执行...
```
可重入锁又叫递归锁，即线程的某个子流程可以获得到锁，那么这个线程的其他子流程也可以获得到锁。
可重入锁的实现简单说就是获得锁的时候先判断当前线程是否是占有锁的线程，如果是就直接返回获取到锁。
`synchronized`与`ReentrantLock`均为可重入锁。

### 3.5 排他锁、共享锁
排他锁、共享锁也是一种概念。
**排他锁**，即当前线程获取到了就不允许任何线程进行操作。获取排他锁的线程可以对数据进行读写。
**共享锁**，即当前线程获取到了，其他线程也可以加共享锁，但不能加排他锁。获得共享锁的线程只能读数据，不能修改数据。
`ReentrantReadWriteLock`就是共享锁的一种实现，其中有两把锁：`ReadLock`和`WriteLock`，通过读写锁分离可以保证并发读非常高效。

