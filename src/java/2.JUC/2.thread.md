---
date: 2023-05-03
category:
  - JAVA
tag:
  - 并发
  - 线程
---

# JAVA 并发 - 线程基础

[[toc]]


## 2.创建线程的几种方式
### 2.1 继承Thread类
```java
public class MyThread extends Thread{
    @Override
    public void run(){
        System.out.println("当前线程是：" + Thread.currentThread().getName());
    }
}
```
```java
@GetMapping("/thread")
public void testThread(){
    MyThread myThread = new MyThread();
    myThread.start();
    System.out.println("主线程是：" + Thread.currentThread().getName());
}
```
运行结果：
```java
主线程是：http-nio-9000-exec-1
当前线程是：Thread-8
```

### 2.2 实现Runnable接口
```java
public class MyRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println("当前线程是：" + Thread.currentThread().getName());
    }
}
```
```java
@GetMapping("/runnable")
public void testRunnable(){
    MyRunnable myRunnable = new MyRunnable();
    Thread thread = new Thread(myRunnable);
    thread.start();
    System.out.println("主线程是：" + Thread.currentThread().getName());
}
```
运行结果：
```java
主线程是：http-nio-9000-exec-2
当前线程是：Thread-9
```

### 2.3 实现Callable接口
```java
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        System.out.println("当前线程是：" + Thread.currentThread().getName());
        return "这是来自子线程" + Thread.currentThread().getName() + "的信息，返回给主线程";
    }
}
```
```java
@GetMapping("/callable")
public void testCallable() throws ExecutionException, InterruptedException {
    MyCallable myCallable = new MyCallable();
    FutureTask<String> futureTask = new FutureTask<>(myCallable);
    Thread thread = new Thread(futureTask);
    thread.start();
    System.out.println(futureTask.get());
    System.out.println("主线程是：" + Thread.currentThread().getName());
}
```
运行结果：
```java
当前线程是：Thread-8
这是来自子线程Thread-8的信息，返回给主线程
主线程是：http-nio-9000-exec-1
```
可以看到子线程的值，返回给了主线程。
**Callable和Runnable的区别有以下三点**：
1、实现Callable的时候需要带一个泛型，重写call()方法的时候需要有返回值；Runnable重写run()方法没有返回值
2、Callable结合FutureTask使用可以获取返回值的结果。
3、Callable的call()方法允许抛出异常，Runnable的run()方法不可以抛出异常，只能内部消化。

### 2.4 线程池创建线程
复用Runnable的实现类
```java
@GetMapping("/executors")
public void testExecutors(){
    ExecutorService threadPool = Executors.newFixedThreadPool(3);
    MyRunnable myRunnable = new MyRunnable();
    threadPool.submit(myRunnable);
    threadPool.submit(myRunnable);
    threadPool.submit(myRunnable);
    threadPool.submit(myRunnable);
    System.out.println("主线程是：" + Thread.currentThread().getName());
}
```
运行结果：
```java
主线程是：http-nio-9000-exec-1
当前线程是：pool-1-thread-1
当前线程是：pool-1-thread-1
当前线程是：pool-1-thread-2
当前线程是：pool-1-thread-3
```
可以发现FixedThreadPool线程池最大线程数为3，提交了四个Runnable，复用了一个线程，具体可以看线程池一节。