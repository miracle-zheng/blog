---
date: 2023-06-05
category:
  - JAVA
tag:
  - Spring
  - 框架
---

# Spring - SpringFramework

## 1.IOC
IOC即Inversion of Control（控制反转），他是一种设计思想，对比于传统的创建对象方式，在业务中new一个对象来使用；IOC最大的特点就是spring是通过IOC容器来创建管理对象

IOC让程序员不再关注怎么去创建对象，而是关注创建对象之后的操作，把对象的创建、初始化、销毁等工作交给IOC容器来做。

BeanFactory是IOC容器的核心interface，常用的ApplicationContext就是他的一个具体实现，其中定义了一个核心的beanDefinitionMap
```java
private final Map<String, BeanDefinition> beanDefinitionMap;
```
beanDefinitionMap的Key为Bean的名字，Value为BeanDefinition，BeanDefinition中包含了很多Bean的元数据，例如：

- class，表示Bean类型
- scope，表示Bean作用域，单例或原型等
- lazyInit：表示Bean是否是懒加载
- initMethodName：表示Bean初始化时要执行的方法
- destroyMethodName：表示Bean销毁时要执行的方法 

而单例Bean的对象实际存在一个单例池——`singletonObjects`中：
```java
# DefaultSingletonBeanRegistry.class
private final Map<String, Object> singletonObjects = new ConcurrentHashMap(256);
```

所以说，在用户使用时：

- 在Bean初始化的时候，会将Bean的基本信息注册到beanDefinitionMap中，根据scope判断如果是单例Bean，还会new一个Bean的对象，放进单例池中（懒加载除外）。
- 在使用getBean()方法获取Bean的时候，根据scope判断是单例Bean还是原型Bean，如果是单例Bean就从这个单例池中取出，如果是原型Bean就new一个返回。

### 1.1 DI（依赖注入）
依赖注入是实现IOC思想的一种具体实现，即Bean对象中的成员变量，由Spring容器进行注入，有两种方式进行注入：
- 基于XML注入
- 基于注解注入

## 2.Bean的生命周期

Spring的Bean与new的对象有很多区别，例如没有依赖注入的值。说明Spring需要一系列的初始化，才能将一个类变为一个Bean，示例流程如下：

UserService.class的无参构造方法 -> 对象 -> 依赖注入（给属性赋值）-> 初始化前（@PostConstruct）-> 初始化（InitlalizingBean） -> 初始化后（AOP） -> Bean

### 2.1 推断构造方法
Spring在将类实例化的时候，需要确定使用哪个类的构造方法，并且用这个方法把这个类实例化成对象，主要规则如下：

1、如果一个类只有一个构造方法，Spring则会使用此构造方法
2、如果一个类没有构造方法，Spring则会使用默认的无参构造方法
3、如果一个类有多个构造方法，并且其中包含无参构造方法，Spring会使用这个无参构造方法
4、如果一个类有多个构造方法，且都是有参构造方法，Spring会报错

Spring的思路其实比较简单，如果一个类只有一个构造方法，那没得选，只能用这一个；如果多个构造方法，则去找其中的无参构造方法，因为无参构造方法本身就有一种默认的意义。如果在某个构造方法上加上@Autowire，则是为Spring指明了要用哪个构造方法实例化这个类。

### 2.2 依赖注入
得到一个对象后，Spring会判断该对象中是否有被@Autowire、@Resource、@Value等注解修饰的属性，这些属性由Spring进行赋值（依赖注入）

- @Value：将值注入到变量或方法当中，值可以直接指定，也可以从配置文件中获取
- @Autowire：作用于成员变量上，将值自动装配进来，默认是ByType策略，即根据变量类型从IOC容器中查找，可以配合@Qualifier注解指定Name，用ByName策略
- @Resource：作用于成员变量上，将值自动装配进来，默认是ByName策略，即根据变量的名称从IOC容器中查找，如果没有找到再使用ByType策略查找

### 2.3 Aware接口
依赖注入后，Spring会判断这个类是否实现了Aware回调接口（BeanNameAware、ApplicationContextAware、BeanFactoryAware等），如果有则调用当前类中实现的setBeanName()、setApplicaitonContext()、setBeanFactory()方法，并且把对应的值（BeanName、ApplicationContext、BeanFactory）作为入参传入方法中，用户可以在此方法中将其设置到局部变量里

### 2.4 初始化前BeanPostProcessor#Before
如果实现了BeanPostProcessor后置处理器接口中定义的postProcessBeforeInitialization()方法（可以实现多个），Spring会在所有Bean创建的时候回调所有实现的postProcessBeforeInitialization()方法。

### 2.5 初始化@PostConstruct
Spring会判断此类中是否有被@PostConstruct注解修饰的方法，如果存在，Spring会调用当前对象的此方法。

### 2.6 初始化InitializingBean
Spring会判断此类是否实现了InitializingBean接口，如果实现了则此类中一定实现了afterPropertiesSet()方法，Spring会调用当前对象中的此方法。

### 2.7 初始化后BeanPostProcessor#After
如果实现了BeanPostProcessor后置处理器接口中定义的postProcessAfterInitialization()方法（可以实现多个），Spring会在所有Bean创建的时候回调所有的实现的postProcessAfterInitialization()方法。

### 2.8 销毁Bean
Spring在ioc容器close的时候，会判断此类是否实现了DisposableBean接口，如果实现了此类中一定实现了destroy()方法，Spring会调用此方法；或者判断有没有@PreDestroy注释的方法，如果有也会调用

**验证代码**如下：

MyBean.java
```java
@Component
public class myBean implements BeanNameAware, InitializingBean, DisposableBean {

    public myBean (){
        System.out.println("开始推断构造方法，这是无参的构造方法");
    }

    public myBean (String test){
        System.out.println("开始推断构造方法，这是有参的构造方法");
    }

    @Value("wangzheng")
    public void setName(String name){
        System.out.println("开始进行依赖注入，注入了name为" + name);
    }

    @Override
    public void setBeanName(String s) {
        System.out.println("开始执行Aware方法，返回了BeanName为：" + s);
    }

    @PostConstruct
    public void testPostConstruct(){
        System.out.println("开始执行被PostConstruct注解的方法");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("开始执行InitializingBean接口的afterPropertiesSet方法");
    }

    @Override
    public void destroy() throws Exception {
        System.out.println("这里要执行销毁时的方法");
    }
}
```
customBeanPostProcessor.java
```java
@Component
public class customBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if (beanName.equals("myBean")) {
            System.out.println("这里执行了BeanPostProcessor中Before方法" + beanName);
        }
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if (beanName.equals("myBean")) {
            System.out.println("这里执行了BeanPostProcessor中After方法" + beanName);
        }
        return bean;
    }
}
```
运行后查看日志：
```java
开始推断构造方法，这是无参的构造方法
开始进行依赖注入，注入了name为wangzheng
开始执行Aware方法，返回了BeanName为：myBean
这里执行了BeanPostProcessor中Before方法myBean
开始执行被PostConstruct注解的方法
开始执行InitializingBean接口的afterPropertiesSet方法
这里执行了BeanPostProcessor中After方法myBean
2023-07-03 16:25:22.319  INFO 23152 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 9000 (http) with context path ''
2023-07-03 16:25:22.326  INFO 23152 --- [           main] com.example.wzdemo.WzdemoApplication     : Started WzdemoApplication in 1.61 seconds (JVM running for 2.402)
Disconnected from the target VM, address: '127.0.0.1:55647', transport: 'socket'
这里要执行销毁时的方法

Process finished with exit code 130
```
