---
date: 2022-11-01
category:
  - JAVA
tag:
  - 基础
---

# JAVA 基础 - 面向对象

[[toc]]

## 1.面向对象的四个特点
- **抽象**：抽象是将一类对象的共有特征总结出一个抽象类，抽象类只关心对象有哪些属性和行为，不关注行为细节
- **封装**：把对象里的某些属性私有化，只提供可以被外部访问的属性和方法。
- **继承**：子类可以继承父类的非private的属性和方法，并且还可以增加自己的属性与方法。
- **多态**：一个引用变量到底会指向哪个类的实例对象，由程序运行时决定。向下转型：子类类型 变量名 = （子类类型） 父类类型的变量

## 2.抽象类与接口的关系
- **相同点**：
接口和抽象类都不能实例化。
都包含抽象方法，子类必须重写这些方法
- **不同点**：
抽象类的子类使用extends继承抽象类，接口的实现类用implements来实现接口
一个类只能继承一个抽象类，一个类可以实现多个接口

## 3.普通类与抽象类的区别
普通类里不能包含抽象方法，抽象类里肯定可以
抽象类不能实例化，普通类可以。
延伸：抽象类可以被final修饰吗？不能，抽象类本身没有意义，定义出来就是为了让别人继承的，然而定义为final该类不能被继承，有悖设计初衷。

## 4.类的构造方法作用
构造方法主要作用是完成类对象的初始化工作，一个类即使没有声明构造方法，也默认提供一个不带参数的构造方法。可以存在多个构造方法

## 5.方法的重载和重写
- **重载**：发生在在同一个类中，方法名相同但入参不同的这种情况
- **重写**：发生在父类子类中，方法名和参数都相同，子类覆盖父类逻辑的这种情况

## 6.重写equals()和hashcode()方法
`equals()`和`hashcode()`都是`Object`类中的方法，一般在对类需要重写`equals()`方法的时候，同时也需要重写`hashcode()`方法。
主要原因是因为JAVA中有一个约定即两个对象根据`equals()`方法判断相等的时候，那么他们的`hashCode()`方法的返回值int也必须相等。
这个约定主要保证了JAVA集合类（`HashMap`、`HashSet`），此类作为集合的Key的情况，由于未重写`hashcode()`方法，也就是说存在两个相同的对象k1、k2（equals返回true），但hashcode不同的情况，如果以他为key，执行两个put操作（k1，v1）（k2，v2），正常逻辑来说应该是用v2覆盖v1的值，但是由于认为key的hashcode不同，就会导致hashmap乱套，详见HashMap。
hashcode简单理解：是根据对象的内存地址通过哈希算出来的一个值。

## 7.JAVA创建对象的几种方式
1. new一个对象
2. 反射
3. clone方法
4. 反序列化